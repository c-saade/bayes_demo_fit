---
title: "Unraveling Time Series with RStan: A Bayesian Approach to Demographic Modeling"
author: "Camille Saade"
date: '2023-07-27'
output:
  html_document:
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Demographic models are an invaluable tool in ecology, as they offer insights into the dynamics of species over time.
By estimating ecologically relevant parameters - such as growth rates and competition strength - these models shed light on complex ecological systems and eventually to predict their future dynamics or produce in-silico experiments.

However, fitting these models can be quite complex and using them for prediction requires robust parameter estimation for prediction purpose.
In particular, traditional frequentist approaches often lack the flexibility to accomodate complex models and they offer point estimates which risk missing identifiability issues.
Bayesian approaches on the other hand, are well suited to estimate parameter distributions and allow to identify pathological correlations between parameters at a glance.

In this article, we will use RStan - a bayesian statistical R package - to analyze time series of two interacting species and find out the mechanisms underlying their dynamics.

## Data

In one of my [research projects](https://doi.org/10.1098/rspb.2022.0543) I studied ecosystems recovery dynamics using microcosms - _i.e._, small laboratory ecosystems made up of microorganisms.
To overcome laboratory limitations of experiment duration and ecosystem size, I also reproduced and expanded the experiment _in silico_.
To get a robust parameterization of the simulations, I fitted a demographic model to preliminary data.
We will work with this preliminary data, consisting of growth curves of several unicellular species in isolation and in co-culture.
All species feed on the same resource and are thus in competition when grown together.
Let's first load and inspect the data:

```{r}
density_data = read.csv("./Data/density_data.csv", header = T, sep = ',')
head(density_data, 10)
```

Each line contains the density (individuals/mL) of each species in one of the tubes (identified by the column 'file') at a given point in time (given either by the columns 'date' and 'time' or by the column 'hours').
Each species association ('community') was replicated three times, and replicates are differentiated using the 'replicate' column.
The columns 'Tet', 'Pca', 'Ble' and 'Col' describe the density of four unicellular species, respectively _Tetrahymena thermophila_, _Paramecium caudatum_, _Colpidium_ sp. and _Blepharisma_ sp.

Here is a summary of the columns content:

  - "file": the name of the video sample used for species count and identification, serves as a unique id for each tube.
  - "date": date at which the sample was taken (yyyy-mm-dd).
  - "time": the time of day at which the sample was taken (hour).
  - "community": the species grown in a tube.
  - "replicate": the replicate number.
  - "measure_point": the number of the measurement (t0 to t11)
  - "Tet": the density (individuals/mL) of _Tetrahymena thermophila_
  - "Pca": the density (individuals/mL) of _Paramecium caudatum_ (a species initially considered in the pilot, not used in the final study)
  - "Col": the density (individuals/mL) of _Colpidium_ sp.
  - "Ble": the density (individuals/mL) of _Blepharisma_ sp.
  - "hours": the time passed since the beginning of the culture (in hours).

Let us take a look at the data:
```{r, warning=FALSE, message = FALSE}
# plotting the whole data
library(tidyverse)
theme_set(theme_light())
density_data %>%
  mutate(Ble = replace(Ble, !grepl('Ble', community), NA)) %>%
  mutate(Col = replace(Col, !grepl('Col', community), NA)) %>%
  mutate(Tet = replace(Tet, !grepl('Tet', community), NA)) %>%
  mutate(Pca = replace(Pca, !grepl('Pca', community), NA)) %>%
  pivot_longer(cols = c("Ble", "Col", "Tet", "Pca"),
               names_to = "species",
               values_to = "density") %>%
  ggplot() +
  geom_point(mapping = aes(x = hours, y = density, color = species)) +
  geom_line(mapping = aes(x = hours, y = density, color = species, group = interaction(species, replicate)), alpha = 0.5) +
  scale_y_continuous(trans='log2') +
  facet_wrap(community ~ .) +
  ylab('Species density (log2(indiv./mL))') +
  xlab('Time (h)')
```
We show here the density (on a log scale) over time of species for each species combination.
This makes a large data set on which to fit a single model.
For the sake of simplicity, we will work only on a subset of the data: the co-culture of _Blepharisma_ sp. and _Tetrahymena_ sp., and we will average the data across replicates.
If you wish to explore how to take advantage of monocultures, tri-cultures and replications, you can have a look into the papers [data and code](https://doi.org/10.5281/zenodo.6364903).
Let's filter the data and average across replicates:

```{r}
# filtering data
filtered_data <- 
  density_data %>%
  filter(community == 'Ble_Tet') %>% # keeping only the bi-specific time series (Blepharisma sp. + Tetrahymena sp.)
  select(c(measure_point, hours, Ble, Tet)) %>% # keeping only time variables and species densities
  group_by(measure_point) %>% # averaging each measurement over replicates
  summarise(t = mean(hours), n1 = mean(Ble), n2 = mean(Tet)) %>%
  arrange(t) # sorting by time
```

```{r}
# plotting the resulting data
library(ggpubr)

panel_a = ggplot(data = filtered_data) +
  geom_point(mapping = aes(x = t, y = n1), color = 'blue') +
  xlab('Time (h)') +
  ylab('Density of Blepharisma sp. (indiv./mL)')

panel_b = ggplot(data = filtered_data) +
  geom_point(mapping = aes(x = t, y = n2), color = 'red') +
  xlab('Time (h)') +
  ylab('Density of Tetrahymena sp. (indiv./mL)')

ggarrange(panel_a, panel_b, nrow = 2)
```

We end up with a single time series for _Blepharisma_ sp. (blue) and for _Tetrahymena_ sp. (red), which is much more manageable in the context of this guide.
For now we can only describe the dynamics verbally: the population _Tetrahymena thermophila_ grows very fast, reaching a fairly high density of 6000 individuals per mL under 100 hours, before crashing down as the population of _Blepharisma_ sp. grow.
On the opposite, the population of _Blepharisma_ sp. grows fairly slowly, seemingly reaching an equilibrium density of 150 individuals per mL in over 200 hours.
Fitting a demographic model onto this data would allow us to numerically quantify these observations as well as unobservable quantities such as competition rates.

Before delving into the model specifics, the last thing we want to do is transform this data into a list that is manageable by Rstan:

```{r}
# turning data into a list to give to the Rstan sampler.
data = list(n  = nrow(filtered_data), # number of observations
            t = filtered_data$t, # vector of times
            n1 = filtered_data$n1, # vector of density of species 1 (Ble)
            n2 = filtered_data$n2) # vector of density of species 2 (Tet)
```

## Demographic model

Species dynamics in ecology are often described using differential equations describe the instantaneous growth rate as a function of the species density.
The go-to model to describe the dynamics of two species in competition is the [competitive Lotka-Volterra model](https://en.wikipedia.org/wiki/Competitive_Lotka%E2%80%93Volterra_equations):

$$
\begin{aligned}
\dfrac{dn_1}{dt} = r_1 n_1 \left(1 - \dfrac{n_1 + \alpha_1 n_2}{K_1} \right)\\
\dfrac{dn_2}{dt} = r_2 n_2 \left(1 - \dfrac{n_2 + \alpha_2 n_1}{K_2} \right)
\end{aligned}
$$
With the following variables:

  - $t$, the time.
  - $n_1$ and $n_2$, the densities of species 1 and 2.
  
And the following parameters

  - $r_1$ and $r_2$, the growth rates of species 1 and 2.
  - $K_1$ and $K_2$, the carrying capacities of species 1 and 2 (_i.e._, their equilibrium density when grown in isolation).
  - $\alpha_1$ and $\alpha_2$, the competition rates: $\alpha_1$ measures the effect that an individual of species 2 has on the growth of species 1 and conversely.
$\alpha_1 \sim 0$ would mean that species 2 has no effect on species 1 (_e.g._, if species 1 is way more efficient than species 2, or if the two species do not compete for the same resource).
$\alpha_1 \sim 1$ would mean that the two species are competitively equivalent.
$\alpha_1 > 1$ would mean that species 2 has a strong negative effect on the growth of species 1.

We thus need to infer the 6 model parameters ($r_1$, $r_2$, $K_1$, $K_2$, $\alpha_1$, $\alpha_2$) as well as the initial conditions for species densities since the measured initial conditions suffer from measurement errors and cannot be used as true values. We will write these initial conditions $n_{10sim}$ and $n_{20sim}$.

## Stan implementation

We can specify the model in [stan's programming language](https://mc-stan.org/docs/reference-manual/index.html), a pseudo C language.
We write the model as a string (or a text file) organized in several blocks:

  - __functions__: to declare any utility functions necessary to the fit.
  - __data__: to declare the structure (type, size...) of the data fed to the model.
  - __parameters__: to declare the model parameters.
  - __model__: to declare parameter priors and how to compute the likelyhood.
  - __generated quantities__: to declare any quantity we want the sampler to compute along the way.
  
```{r}
model_str = '
functions{
  real[] odemodel(real t, real[] N, real[] p, real[] x_r, int[] x_i){
    // p[1]=r1, p[2] = r2, p[3] = K1, p[4] = K2, p[5] = alpha1, p[6] = alpha2 
    real dNdt[2]; 
    dNdt[1] = p[1]*N[1]*(1 - (N[1] + p[5]*N[2])/p[3]);
    dNdt[2] = p[2]*N[2]*(1 - (p[6]*N[1] + N[2])/p[4]);
    return dNdt;
  }
}

data{
  int n; // number of observations
  real t[n]; // time
  real n1[n]; // observations n1
  real n2[n]; // observations n2
}

parameters{
  real<lower=0> r1; // growth rate
  real<lower=0> r2; // growth rate
  real<lower=0> K1; // carrying capacity
  real<lower=0> K2; // carrying capacity
  real<lower=0> alpha1; // comp term
  real<lower=0> alpha2; // comp term
  real<lower=0> n10sim; // initial density n1
  real<lower=0> n20sim; // initial density n2
  real<lower=0> sdev1;
  real<lower=0> sdev2;
}

model{
  real p[6]; // vector of parameters for the ODE
  real simval[n-1,2]; // simulated values, matrix. dim1 = time without t0, dim2 = dim_ODE = 2 (S = 1, I = 2)
  
  // priors 
  r1 ~ lognormal(-3,1);
  r2 ~ lognormal(-2,1);
  K1 ~ lognormal(5, 0.8);
  K2 ~ lognormal(8, 0.5);
  alpha1 ~ lognormal(-3,1);
  alpha2 ~ lognormal(2.5,1);
  n10sim ~ normal(n1[1],5);
  n20sim ~ normal(n2[1],10);
  sdev1 ~ gamma(1, 1);
  sdev2 ~ gamma(1, 1);
  
  // parameters for integrator
  p[1] = r1;
  p[2] = r2;
  p[3] = K1;
  p[4] = K2;
  p[5] = alpha1;
  p[6] = alpha2;

  // integrate ODE
  simval = integrate_ode_rk45(odemodel, {n10sim, n20sim}, t[1], t[2:n], p, rep_array(0.0,0), rep_array(0,0));
  // likelihood
  n1[1] ~ normal(n10sim, sdev1);
  n2[1] ~ normal(n20sim, sdev2);
  for (i in 2:n){
    n1[i] ~ normal(simval[i-1, 1], sdev1);
    n2[i] ~ normal(simval[i-1, 2], sdev2);
  }
}

generated quantities{
}
'
```

### functions

```{}
functions{
  real[] odemodel(real t, real[] N, real[] p, real[] x_r, int[] x_i){
    // p[1]=r1, p[2] = r2, p[3] = K1, p[4] = K2, p[5] = alpha1, p[6] = alpha2 
    real dNdt[2]; 
    dNdt[1] = p[1]*N[1]*(1 - (N[1] + p[5]*N[2])/p[3]);
    dNdt[2] = p[2]*N[2]*(1 - (p[6]*N[1] + N[2])/p[4]);
    return dNdt;
  }
}
```



### data

```{}
data{
  int n; // number of observations
  real t[n]; // time
  real n1[n]; // observations n1
  real n2[n]; // observations n2
}
```



### parameters

```{}
parameters{
  real<lower=0> r1; // growth rate
  real<lower=0> r2; // growth rate
  real<lower=0> K1; // carrying capacity
  real<lower=0> K2; // carrying capacity
  real<lower=0> alpha1; // comp term
  real<lower=0> alpha2; // comp term
  real<lower=0> n10sim; // initial density n1
  real<lower=0> n20sim; // initial density n2
  real<lower=0> sdev1;
  real<lower=0> sdev2;
}
```


### model

```{}
model{
  real p[6]; // vector of parameters for the ODE
  real simval[n-1,2]; // simulated values, matrix. dim1 = time without t0, dim2 = dim_ODE = 2 (S = 1, I = 2)
  
  // priors 
  r1 ~ lognormal(-3,1);
  r2 ~ lognormal(-2,1);
  K1 ~ lognormal(5, 0.8);
  K2 ~ lognormal(8, 0.5);
  alpha1 ~ lognormal(-3,1);
  alpha2 ~ lognormal(2.5,1);
  n10sim ~ normal(n1[1],5);
  n20sim ~ normal(n2[1],10);
  sdev1 ~ gamma(1, 1);
  sdev2 ~ gamma(1, 1);
  
  // parameters for integrator
  p[1] = r1;
  p[2] = r2;
  p[3] = K1;
  p[4] = K2;
  p[5] = alpha1;
  p[6] = alpha2;

  // integrate ODE
  simval = integrate_ode_rk45(odemodel, {n10sim, n20sim}, t[1], t[2:n], p, rep_array(0.0,0), rep_array(0,0));
  // likelihood
  n1[1] ~ normal(n10sim, sdev1);
  n2[1] ~ normal(n20sim, sdev2);
  for (i in 2:n){
    n1[i] ~ normal(simval[i-1, 1], sdev1);
    n2[i] ~ normal(simval[i-1, 2], sdev2);
  }
}
```

### generated quantities

```{}
generated quantities{
}
```


## Model diagnostic

## Posterior predictions
